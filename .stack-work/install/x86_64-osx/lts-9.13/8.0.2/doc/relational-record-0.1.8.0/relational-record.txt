-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Meta package of Relational Record
--   
--   Meta package to install Relational Record quickly
@package relational-record
@version 0.1.8.0


-- | This module is documentation module for relational-record. The project
--   page of relational-record is
--   <a>http://khibino.github.io/haskell-relational-record/</a> .
module Database.Relational.Query.Documentation

-- | Join sub-query. Query result is not <a>Maybe</a>.
query :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat r)

-- | Join sub-query. Query result is <a>Maybe</a>. The combinations of
--   <a>query</a> and <a>queryMaybe</a> express inner joins, left outer
--   joins, right outer joins, and full outer joins. Here is an example of
--   a right outer join:
--   
--   <pre>
--   outerJoin = relation $ do
--     e &lt;- queryMaybe employee
--     d &lt;- query department
--     on $ e ?! E.deptId' .=. just (d ! D.deptId')
--     return $ (,) |$| e |*| d
--   </pre>
queryMaybe :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat (Maybe r))

-- | Add restriction to last join. Projection type version.
on :: MonadQuery m => Projection Flat (Maybe Bool) -> m ()

-- | Add restriction to this not aggregated query.
wheres :: MonadRestrict Flat m => Projection Flat (Maybe Bool) -> m ()

-- | Add <i>GROUP BY</i> term into context and get aggregated projection.
groupBy :: MonadAggregate m => forall r. Projection Flat r -> m (Projection Aggregated r)

-- | Add restriction to this aggregated query. Aggregated Projection type
--   version.
having :: MonadRestrict Aggregated m => Projection Aggregated (Maybe Bool) -> m ()

-- | Specify DISTINCT attribute to query context.
distinct :: MonadQuery m => m ()

-- | Specify ALL attribute to query context.
all' :: MonadQuery m => m ()

-- | Add and assginment.
(<-#) :: Monad m => AssignTarget r v -> Projection Flat v -> Assignings r m ()
infix 4 <-#

-- | Direct inner join.
inner :: Relation () a -> Relation () b -> [JoinRestriction a b] -> Relation () (a, b)
infixl 8 `inner`

-- | Direct left outer join.
left :: Relation () a -> Relation () b -> [JoinRestriction a (Maybe b)] -> Relation () (a, Maybe b)
infixl 8 `left`

-- | Direct right outer join.
right :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) b] -> Relation () (Maybe a, b)
infixl 8 `right`

-- | Direct full outer join.
full :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) (Maybe b)] -> Relation () (Maybe a, Maybe b)
infixl 8 `full`

-- | Apply restriction for direct join style.
on' :: ([JoinRestriction a b] -> Relation pc (a, b)) -> [JoinRestriction a b] -> Relation pc (a, b)
infixl 8 `on'`

-- | Restriction predicate function type for direct style join operator,
--   used on predicates of direct join style as follows.
--   
--   <pre>
--   do xy &lt;- query $
--            relX <a>inner</a> relY <a>on'</a> [ x y -&gt; ... ] -- this lambda form has JoinRestriction type
--      ...
--   </pre>
type JoinRestriction a b = Projection Flat a -> Projection Flat b -> Projection Flat (Maybe Bool)

-- | Relation type with place-holder parameter <tt>p</tt> and query result
--   type <tt>r</tt>.
data Relation p r :: * -> * -> *

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a>.
relation :: QuerySimple (Projection Flat r) -> Relation () r

-- | Finalize <a>QueryAggregate</a> monad and geneate <a>Relation</a>.
aggregateRelation :: QueryAggregate (Projection Aggregated r) -> Relation () r

-- | UpdateTarget type with place-holder parameter <tt>p</tt> and
--   projection record type <tt>r</tt>.
data UpdateTarget p r :: * -> * -> *

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a>.
updateTarget :: AssignStatement r () -> UpdateTarget () r

-- | Restriction type with place-holder parameter <tt>p</tt> and projection
--   record type <tt>r</tt>.
data Restriction p r :: * -> * -> *

-- | Finalize <tt>Restrict</tt> monad and generate <a>Restriction</a>.
restriction :: RestrictedStatement r () -> Restriction () r

-- | Phantom typed projection. Projected into Haskell record type
--   <tt>t</tt>.
data Projection c t :: * -> * -> *

-- | Type tag for flat (not-aggregated) query
data Flat :: *

-- | Type tag for aggregated query
data Aggregated :: *

-- | Type tag for exists predicate
data Exists :: *

-- | Type tag for window function building
data OverWindow :: *

-- | Projection path from type <tt>r0</tt> into type <tt>r1</tt>. This type
--   also indicate key object which type is <tt>r1</tt> for record type
--   <tt>r0</tt>.
data Pi r0 r1 :: * -> * -> *

-- | Get narrower projection along with projection path.
(!) :: PersistableWidth a => Projection c a -> Pi a b -> Projection c b
infixl 8 !

-- | Compose projection path.
(<.>) :: Pi a b -> Pi b c -> Pi a c
infixl 8 <.>

-- | <a>ShowConstantTermsSQL</a> <tt>a</tt> is implicit rule to derive
--   function to convert from haskell record type <tt>a</tt> into constant
--   SQL terms.
--   
--   Generic programming
--   (<a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming</a>)
--   with default signature is available for <a>ShowConstantTermsSQL</a>
--   class, so you can make instance like below:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   import GHC.Generics (Generic)
--   --
--   data Foo = Foo { ... } deriving Generic
--   instance ShowConstantTermsSQL Foo
--   </pre>
class ShowConstantTermsSQL a

-- | Generate polymorphic projection of SQL constant values from Haskell
--   value.
value :: (ShowConstantTermsSQL t, OperatorProjectable p) => t -> p t

-- | Polymorphic proejction of SQL set value from Haskell list.
values :: (ShowConstantTermsSQL t, OperatorProjectable p) => [t] -> ListProjection p t

-- | Compare operator corresponding SQL <i>=</i> .
(.=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .=.

-- | Compare operator corresponding SQL <i>&lt;</i> .
(.<.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .<.

-- | Compare operator corresponding SQL <i>&lt;=</i> .
(.<=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .<=.

-- | Compare operator corresponding SQL <i>&gt;</i> .
(.>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .>.

-- | Compare operator corresponding SQL <i>&gt;=</i> .
(.>=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .>=.

-- | Compare operator corresponding SQL <i>&lt;&gt;</i> .
(.<>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)
infix 4 .<>.

-- | Logical operator corresponding SQL <i>AND</i> .
and' :: (OperatorProjectable p, ProjectableShowSql p) => p (Maybe Bool) -> p (Maybe Bool) -> p (Maybe Bool)
infixr 3 `and'`

-- | Logical operator corresponding SQL <i>OR</i> .
or' :: (OperatorProjectable p, ProjectableShowSql p) => p (Maybe Bool) -> p (Maybe Bool) -> p (Maybe Bool)
infixr 2 `or'`

-- | Binary operator corresponding SQL <i>IN</i> .
in' :: (OperatorProjectable p, ProjectableShowSql p) => p t -> ListProjection p t -> p (Maybe Bool)
infix 4 `in'`

-- | Concatinate operator corresponding SQL <i>||</i> .
(.||.) :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p a
infixl 5 .||.

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like :: (OperatorProjectable p, ProjectableShowSql p, IsString a, ShowConstantTermsSQL a) => p a -> a -> p (Maybe Bool)
infix 4 `like`

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like' :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p (Maybe Bool)
infix 4 `like'`

-- | Number operator corresponding SQL <i>+</i> .
(.+.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a
infixl 6 .+.

-- | Number operator corresponding SQL <i>-</i> .
(.-.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a
infixl 6 .-.

-- | Number operator corresponding SQL <i>*</i> .
(.*.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a
infixl 7 .*.

-- | Number operator corresponding SQL /// .
(./.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a
infixl 7 ./.

-- | Operator corresponding SQL <i>IS NULL</i> , and extended against
--   record types.
isNothing :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator corresponding SQL <i>NOT (... IS NULL)</i> , and extended
--   against record type.
isJust :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator from maybe type using record extended <tt>isNull</tt>.
fromMaybe :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c r -> Projection c (Maybe r) -> Projection c r

-- | Logical operator corresponding SQL <i>NOT</i> .
not' :: (OperatorProjectable p, ProjectableShowSql p) => p (Maybe Bool) -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>EXISTS</i> .
exists :: (OperatorProjectable p, ProjectableShowSql p) => ListProjection (Projection Exists) r -> p (Maybe Bool)

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negate' :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a

-- | Number fromIntegral uni-operator.
fromIntegral' :: (SqlProjectable p, ProjectableShowSql p, Integral a, Num b) => p a -> p b

-- | Unsafely show number into string-like type in projections.
showNum :: (SqlProjectable p, ProjectableShowSql p, Num a, IsString b) => p a -> p b

-- | Same as <a>caseSearch</a>, but you can write like <a>list</a>
--   <a>casesOrElse</a> <a>clause</a>.
casesOrElse :: OperatorProjectable (Projection c) => [(Projection c (Maybe Bool), Projection c a)] -> Projection c a -> Projection c a

-- | Simple case operator correnponding SQL simple <i>CASE</i>. Like,
--   <i>CASE x WHEN v THEN a WHEN w THEN b ... ELSE c END</i>
case' :: OperatorProjectable (Projection c) => Projection c a -> [(Projection c a, Projection c b)] -> Projection c b -> Projection c b

-- | Aggregation function COUNT.
count :: (Integral b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac b

-- | Aggregation function SUM.
sum' :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function AVG.
avg :: (Num a, Fractional b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe b)

-- | Aggregation function MAX.
max' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function MIN.
min' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function EVERY.
every :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function ANY.
any' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function SOME.
some' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Operator to make window function result projection using built
--   <a>Window</a> monad.
over :: SqlProjectable (Projection c) => Projection OverWindow a -> Window c () -> Projection c a
infix 8 `over`

-- | <i>RANK()</i> term.
rank :: Integral a => Projection OverWindow a

-- | <i>DENSE_RANK()</i> term.
denseRank :: Integral a => Projection OverWindow a

-- | <i>ROW_NUMBER()</i> term.
rowNumber :: Integral a => Projection OverWindow a

-- | <i>PERCENT_RANK()</i> term.
percentRank :: Projection OverWindow Double

-- | <i>CUME_DIST()</i> term.
cumeDist :: Projection OverWindow Double

-- | Union of two relations.
union :: Relation () a -> Relation () a -> Relation () a
infixl 7 `union`

-- | Subtraction of two relations.
except :: Relation () a -> Relation () a -> Relation () a
infixl 7 `except`

-- | Intersection of two relations.
intersect :: Relation () a -> Relation () a -> Relation () a
infixl 8 `intersect`

-- | Cast projection phantom type into <a>Maybe</a>.
just :: ProjectableMaybe p => forall a. p a -> p (Maybe a)

-- | Compose nested <a>Maybe</a> phantom type on projection.
flattenMaybe :: ProjectableMaybe p => forall a. p (Maybe (Maybe a)) -> p (Maybe a)

-- | Get narrower projection along with projection path <a>Maybe</a>
--   phantom functor is <a>map</a>-ed.
(?!) :: PersistableWidth a => Projection c (Maybe a) -> Pi a b -> Projection c (Maybe b)
infixl 8 ?!

-- | Get narrower projection along with projection path and project into
--   result projection type. Source record <a>Maybe</a> phantom functor and
--   projection path leaf <a>Maybe</a> functor are <tt>join</tt>-ed.
(?!?) :: PersistableWidth a => Projection c (Maybe a) -> Pi a (Maybe b) -> Projection c (Maybe b)
infixl 8 ?!?

-- | Compose projection path. <a>Maybe</a> phantom functor is
--   <a>map</a>-ed.
(<?.>) :: Pi a (Maybe b) -> Pi b c -> Pi a (Maybe c)
infixl 8 <?.>

-- | Compose projection path. <a>Maybe</a> phantom functors are
--   <tt>join</tt>-ed like <tt>&gt;=&gt;</tt>.
(<?.?>) :: Pi a (Maybe b) -> Pi b (Maybe c) -> Pi a (Maybe c)
infixl 8 <?.?>

-- | Number operator corresponding SQL <i>+</i> .
(?+?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)
infixl 6 ?+?

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negateMaybe :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a)

-- | Aggregation function SUM.
sumMaybe :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe a)

-- | Provide scoped placeholder and return its parameter object. Monadic
--   version.
placeholder :: (PersistableWidth t, SqlProjectable p, Monad m) => (p t -> m a) -> m (PlaceHolders t, a)

-- | Join sub-query with place-holder parameter <tt>p</tt>. query result is
--   not <a>Maybe</a>.
query' :: MonadQuery m => forall p r. Relation p r -> m (PlaceHolders p, Projection Flat r)

-- | Direct left outer join with place-holder parameters.
left' :: Relation pa a -> Relation pb b -> [JoinRestriction a (Maybe b)] -> Relation (pa, pb) (a, Maybe b)
infixl 8 `left'`

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a> with
--   place-holder parameter <tt>p</tt>.
relation' :: SimpleQuery p r -> Relation p r

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a> with
--   place-holder parameter <tt>p</tt>.
updateTarget' :: AssignStatement r (PlaceHolders p) -> UpdateTarget p r

-- | Finalize <tt>Restrict</tt> monad and generate <a>Restriction</a> with
--   place-holder parameter <tt>p</tt>
restriction' :: RestrictedStatement r (PlaceHolders p) -> Restriction p r

-- | Union of two relations with place-holder parameters.
union' :: Relation p a -> Relation q a -> Relation (p, q) a
infixl 7 `union'`

-- | Specify tuple like record constructors which are allowed to define
--   <a>ProjectableFunctor</a>.
class ProductConstructor r

-- | Weaken functor on projections.
class ProjectableFunctor (p :: * -> *)

-- | Method like <a>fmap</a>.
(|$|) :: (ProjectableFunctor p, ProductConstructor (a -> b)) => (a -> b) -> p a -> p b

-- | Weaken applicative functor on projections.
class ProjectableFunctor p => ProjectableApplicative (p :: * -> *)

-- | Method like <a>&lt;*&gt;</a>.
(|*|) :: ProjectableApplicative p => p (a -> b) -> p a -> p b

-- | Binary operator the same as <a>projectZip</a>.
(><) :: ProjectableApplicative p => p a -> p b -> p (a, b)
infixl 1 ><

-- | From <a>Relation</a> into typed <a>Query</a>.
relationalQuery :: Relation p r -> Query p r

-- | Make typed <a>Insert</a> from <a>Table</a> and columns selector
--   <a>Pi</a>.
typedInsert :: PersistableWidth r => Table r -> Pi r r' -> Insert r'

-- | Make typed <a>InsertQuery</a> from columns selector <a>Table</a>,
--   <a>Pi</a> and <a>Relation</a>.
typedInsertQuery :: Table r -> Pi r r' -> Relation p r' -> InsertQuery p

-- | Make typed <a>Update</a> using <a>defaultConfig</a>, <a>Table</a> and
--   <a>UpdateTarget</a>.
typedUpdate :: Table r -> UpdateTarget p r -> Update p

-- | Make typed <a>Delete</a> from <a>Table</a> and <a>Restriction</a>.
typedDelete :: Table r -> Restriction p r -> Delete p

-- | Make typed <a>KeyUpdate</a> from <a>Table</a> and key columns selector
--   <a>Pi</a>.
typedKeyUpdate :: Table a -> Pi a p -> KeyUpdate p a

-- | Table type inferred <a>Insert</a>.
derivedInsert :: (PersistableWidth r, TableDerivable r) => Pi r r' -> Insert r'

-- | Table type inferred <a>InsertQuery</a>.
derivedInsertQuery :: TableDerivable r => Pi r r' -> Relation p r' -> InsertQuery p

-- | Make typed <a>Update</a> from <a>defaultConfig</a>, derived table and
--   <a>AssignStatement</a>
derivedUpdate :: TableDerivable r => AssignStatement r (PlaceHolders p) -> Update p

-- | Make typed <a>Delete</a> from <a>defaultConfig</a>, derived table and
--   <tt>RestrictContext</tt>
derivedDelete :: TableDerivable r => RestrictedStatement r (PlaceHolders p) -> Delete p

-- | <a>FromSql</a> <tt>q</tt> <tt>a</tt> is implicit rule to derive
--   <a>RecordFromSql</a> <tt>q</tt> <tt>a</tt> record parser function
--   against type <tt>a</tt>.
--   
--   Generic programming
--   (<a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming</a>)
--   with default signature is available for <a>FromSql</a> class, so you
--   can make instance like below:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   import GHC.Generics (Generic)
--   import Database.HDBC (SqlValue)
--   --
--   data Foo = Foo { ... } deriving Generic
--   instance FromSql SqlValue Foo
--   </pre>
class FromSql q a

-- | <a>ToSql</a> <tt>q</tt> <tt>a</tt> is implicit rule to derive
--   <a>RecordToSql</a> <tt>q</tt> <tt>a</tt> record printer function for
--   type <tt>a</tt>.
--   
--   Generic programming
--   (<a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming</a>)
--   with default signature is available for <a>ToSql</a> class, so you can
--   make instance like below:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   import GHC.Generics (Generic)
--   import Database.HDBC (SqlValue)
--   --
--   data Foo = Foo { ... } deriving Generic
--   instance ToSql SqlValue Foo
--   </pre>
--   
--   To make instances of <a>ToSql</a> manually, <a>ToSql</a> <tt>q</tt>
--   <tt>a</tt> and <a>RecordToSql</a> 'q <tt>a</tt> are composable with
--   monadic context. When, you have data constructor and objects like
--   below.
--   
--   <pre>
--   data MyRecord = MyRecord Foo Bar Baz
--   </pre>
--   
--   <pre>
--   instance ToSql SqlValue Foo where
--     ...
--   instance ToSql SqlValue Bar where
--     ...
--   instance ToSql SqlValue Baz where
--     ...
--   </pre>
--   
--   You can get composed <a>ToSql</a> implicit rule like below.
--   
--   <pre>
--   instance ToSql SqlValue MyRecord where
--     recordToSql =
--     recordToSql = wrapToSql $ \ (MyRecord x y z) -&gt; do
--       putRecord x
--       putRecord y
--       putRecord z
--   </pre>
class PersistableWidth a => ToSql q a

-- | <a>RecordFromSql</a> <tt>q</tt> <tt>a</tt> is data-type wrapping
--   function to convert from list of database value type (to receive from
--   database) [<tt>q</tt>] into Haskell type <tt>a</tt>
--   
--   This structure is similar to parser. While running
--   <a>RecordFromSql</a> behavior is the same as non-fail-able parser
--   which parse list of database value type [<tt>q</tt>] stream.
--   
--   So, <a>RecordFromSql</a> <tt>q</tt> is <a>Monad</a> and
--   <a>Applicative</a> instance like parser monad. When, you have data
--   constructor and objects like below.
--   
--   <pre>
--   data MyRecord = MyRecord Foo Bar Baz
--   </pre>
--   
--   <pre>
--   foo :: <a>RecordFromSql</a> SqlValue Foo
--   foo =  ...
--   bar :: <a>RecordFromSql</a> SqlValue Bar
--   bar =  ...
--   baz :: <a>RecordFromSql</a> SqlValue Bar
--   baz =  ...
--   </pre>
--   
--   You can get composed <a>RecordFromSql</a> like below.
--   
--   <pre>
--   myRecord :: RecordFromSql SqlValue MyRecord
--   myRecord =  MyRecord &lt;$&gt; foo &lt;*&gt; bar &lt;*&gt; baz
--   </pre>
data RecordFromSql q a :: * -> * -> *

-- | <a>RecordToSql</a> <tt>q</tt> <tt>a</tt> is data-type wrapping
--   function to convert from Haskell type <tt>a</tt> into list of database
--   value type (to send to database) [<tt>q</tt>].
--   
--   This structure is similar to printer. While running <a>RecordToSql</a>
--   behavior is the same as list printer. which appends list of database
--   value type [<tt>q</tt>] stream.
data RecordToSql q a :: * -> * -> *

-- | Generalized prepare inferred from <a>UntypeableNoFetch</a> instance.
prepareNoFetch :: (UntypeableNoFetch s, IConnection conn) => conn -> s p -> IO (PreparedStatement p ())

-- | Typed operation to bind parameters. Inferred <a>RecordToSql</a> is
--   used.
bind :: ToSql SqlValue p => PreparedStatement p a -> p -> BoundStatement a

-- | Use <a>executeBound</a> instead of this. WARNING! This name will be
--   used for executePrepared function in future release.
execute :: BoundStatement a -> IO (ExecutedStatement a)

-- | Use <a>executeBoundNoFetch</a> instead of this. WARNING! This name
--   will be used for runPreparedNoFetch function in future release.
executeNoFetch :: BoundStatement () -> IO Integer

-- | Same as <a>prepare</a>.
prepareQuery :: IConnection conn => conn -> Query p a -> IO (PreparedQuery p a)

-- | Fetch a record.
fetch :: FromSql SqlValue a => ExecutedStatement a -> IO (Maybe a)

-- | Prepare SQL, bind parameters, execute statement and lazily fetch all
--   records.
runQuery :: (IConnection conn, ToSql SqlValue p, FromSql SqlValue a) => conn -> Query p a -> p -> IO [a]

-- | Strict version of <a>runQuery</a>.
runQuery' :: (IConnection conn, ToSql SqlValue p, FromSql SqlValue a) => conn -> Query p a -> p -> IO [a]

-- | Same as <a>prepare</a>.
prepareInsert :: IConnection conn => conn -> Insert a -> IO (PreparedInsert a)

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runInsert :: (IConnection conn, ToSql SqlValue a) => conn -> Insert a -> a -> IO Integer

-- | Same as <a>prepare</a>.
prepareInsertQuery :: IConnection conn => conn -> InsertQuery p -> IO (PreparedInsertQuery p)

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runInsertQuery :: (IConnection conn, ToSql SqlValue p) => conn -> InsertQuery p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareUpdate :: IConnection conn => conn -> Update p -> IO (PreparedUpdate p)

-- | Prepare update statement, bind parameters, execute statement and get
--   execution result.
runUpdate :: (IConnection conn, ToSql SqlValue p) => conn -> Update p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareDelete :: IConnection conn => conn -> Delete p -> IO (PreparedDelete p)

-- | Prepare delete statement, bind parameters, execute statement and get
--   execution result.
runDelete :: (IConnection conn, ToSql SqlValue p) => conn -> Delete p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareKeyUpdate :: IConnection conn => conn -> KeyUpdate p a -> IO (PreparedKeyUpdate p a)

-- | Typed operation to bind parameters for <a>PreparedKeyUpdate</a> type.
bindKeyUpdate :: ToSql SqlValue a => PreparedKeyUpdate p a -> a -> BoundStatement ()

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runKeyUpdate :: (IConnection conn, ToSql SqlValue a) => conn -> KeyUpdate p a -> a -> IO Integer
